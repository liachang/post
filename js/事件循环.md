#### 背景

```
javascript是一门单线程的非阻塞的脚本语言。
这是由其最初的用途来决定的：与浏览器交互==>解释增删dom
```

```
h5的web worker
web worker技术开的多线程有着诸多限制
所有新线程都受主线程的完全控制，不能独立执行。这意味着这些“线程” 实际上应属于主线程的子线程
这些子线程并没有执行I/O操作的权限，只能为主线程分担一些诸如计算等任务。
```

#### 过程

```
执行栈
而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。 
```

```
同步任务按照代码的执行顺序加入主执行栈
```

```
js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕，主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。
```

```
微任务和宏任务
实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。
不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。
以下事件属于宏任务 Macro Task：
I/O
setInterval()
setTimeout()
以下事件属于微任务 Micro Task
new Promise()
new MutaionObserver()
在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。
并且在当前执行栈为空的时候，主线程会查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈...如此反复，进入循环。
```

```
JavaScript 是一门单线程语言，异步操作都是放到事件循环队列里面，等待主执行栈来执行的，并没有专门的异步执行线程。
```

面试题

```
promise中的then才要进到事件队列，普通console.log立即执行
```

